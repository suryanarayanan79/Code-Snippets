#include <stdexcept>
#include <string>
#include <iostream>
#include<vector>
using namespace std;


int main() {
    vector<int> v1{ 3,3,3,3 };
    vector<int> v2(5);
    for (int i : v2) {
        cout << i;
    }
    cout << endl;

    for (int i : v1) {
        cout << i;
    }
    cout << endl;
    int a[]{ 12,12,12,12 };
    vector<int> v3(4, 344);
    //C++ 11 feature auto Range.
    for (auto v : v3) {
        cout << v;
    }
    cout << endl;
    //Loops never ends sinces the last is not set , 
    //it will never i will never be more than zero.
    for (int i = 0; i < v3.size();/*i++*/ /* comment his out for infinite loop*/) {
    	cout << v3.at(i); // at checks the index out of range execptions.f
    }
}



/////////////////////
Range based for loop in c++ 11
	for (auto c : "This is a test")
		if (c == ' ')
			cout << "\t";
		else
			cout << c;
			
///////////////////
//code for generating bad allocation.Example for Exception handling.
#include <iostream>
#include <exception>

using namespace std;
struct myStruct {
	string name{"ffffffffffffffffffffffffffffffffffffffffffffffffffffffff"};
	long long num{12};
};
class ExceptionExample  {
	myStruct* mystrct1, *mystrct2, *mystrct3, *mystrct4, *mystrct5;
public:
	ExceptionExample() {
		 mystrct1 = new myStruct[9999999];
		 mystrct2 = new myStruct[9999999];
		 mystrct3 = new myStruct[9999999];
		 mystrct4 = new myStruct[9999999];
		 mystrct5 = new myStruct[9999999];
		delete[] mystrct1;
		delete[] mystrct2;
		delete[] mystrct3;
		delete[] mystrct4;
		delete[] mystrct5;
	}
};
int main() {
	try {
		ExceptionExample e;
	}
	catch(bad_alloc &e){
		cout << e.what() << endl;
	}
	return 0;
}

////////////////////////
// demonstraion of subclass exception and parent class exception . 
//Order of the catch block is important here. Always derived class exception should be in the first palce.
#include <iostream>
#include <exception>

using namespace std;

class MyException : public exception {
public:
	virtual const char* what() const throw() {
		// when const throw is mentioned with empty () it means do not throw expetion from this method.
		return "Bad Allocation Happend";
	}

};
struct myStruct {
	string name{"ffffffffffffffffffffffffffffffffffffffffffffffffffffffff"};
	long long num{12};

};

class ExceptionExample  {
	myStruct* mystrct1, *mystrct2, *mystrct3, *mystrct4, *mystrct5;
public:
	ExceptionExample() {
		 mystrct1 = new myStruct[9999999];
		 mystrct2 = new myStruct[9999999];
		 mystrct3 = new myStruct[9999999];
		 mystrct4 = new myStruct[9999999];
		 mystrct5 = new myStruct[9999999];

		delete[] mystrct1;
		delete[] mystrct2;
		delete[] mystrct3;
		delete[] mystrct4;
		delete[] mystrct5;
	}
};
int main() {
	try {
		ExceptionExample e;
	}
	catch(exception &e){
		cout << "Parent Class " << e.what() << endl;
	}
	catch (bad_alloc & e) {
		cout << "Derived Class " << e.what() << endl;
	}
	return 0;
}

////////////////////////////////
MAP Container STL
#include <iostream>
#include <map>

using namespace std;
int main() {
	map<string, int> ages;
	ages["surya"] = 40;
	ages["Apan"] = 35;
	ages["PravarThika"] = 6;
	ages["shalika"] = 9;
	// this add the key to the map.  add a default int 0.
	cout << ages["father"];
	pair<string, int> mypair("Mother", 78);
	//since already key father is there it won't add in the map.
	pair<string, int> mypair2("father", 79);
	ages.insert(mypair);
	ages.insert(mypair2);
	ages.insert(pair<string,int>("self",40));
	ages.insert(make_pair("Father-In-Law",70));

	for (map<string, int>::iterator it = ages.begin(); it != ages.end();it++) {
		cout << "name" << it->first << "\t" << "age" << it->second << endl;
	}

	// To find a key in the map 
	if (ages.find("Mother") != ages.end()) {
		cout << "Key Found" << endl;
	}
	else {
		cout << "Key not Found" << endl;
	}
	return 0;
}
////////////////////////////////////////////////////////
// Map Associative Container.
#include <iostream>
#include <map>
#include <string>
using namespace std;

class Person {
private:
    string name;
    int age;
public:
    Person() :name(""), age(0) {
        cout << "Paramterless Constructor is called" << endl;
    }

    Person(string name, int age) :name(name), age(age) {
        cout << "Parameter Constructor is called" <<endl;
    }

    Person(const Person& other) {
        age = other.age;
        name = other.name;
        cout << "Copy Constructor is called" << endl;
    }

    void Print() const{
        cout << "name :" << name << "age:" << age << endl;
    }
};

using namespace std;
int main() {
	map<int, Person> records;
    //Person person{ "Surya",40 };
    records[1000] = Person("Surya",40);
	pair<int,Person> mypair(2000,Person("Mother",75));
	
	records.insert(mypair);

    // Same key is not allowed in Map DS.
	records.insert(make_pair(3000, Person("Apan", 35)));
	//ages.insert(make_pair("Father-In-Law",70));

	for (map<int, Person>::iterator it = records.begin(); it != records.end();it++) {
         it->second.Print();
	}
	//// To find a key in the map 
	//if (ages.find("Mother") != ages.end()) {
	//	cout << "Key Found" << endl;
	//}
	//else {
	//	cout << "Key not Found" << endl;
	//}
	return 0;
}

//////
// Map Associative Container.
#include <iostream>
#include <map>
#include <string>
using namespace std;

class Person {
private:
    string name;
    int age;
public:
    Person() :name(""), age(0) {
        cout << "Paramterless Constructor is called" << endl;
    }

    Person(string name, int age) :name(name), age(age) {
        cout << "Parameter Constructor is called" << endl;
    }

    Person(const Person& other) {
        age = other.age;
        name = other.name;
        cout << "Copy Constructor is called" << endl;
    }

    bool operator < (const Person& other) const {
        // this will accomodate the Person Object with same name but different age.
        if (name == other.name) {
            return age < other.age;
        }
        else
        {
            return name < other.name;
        }
    }

    void Print() const {
        cout << "name :" << name << "age:" << age << endl;
    }
};

using namespace std;
int main() {
    // Map sort the pair it stores , since Person is a class , map by itself does not know how to sort the person class .
    // Hence we need to provide a operator < overloding to the person class.
    map<Person, int> records;
    records[Person("Surya", 40)] = 1000;

    pair<Person, int> mypair(Person("Mother", 75), 3000);
    records.insert(mypair);
    // Same key is not allowed in Map DS.
    records.insert(make_pair(Person("Apan", 35), 2000));
    records.insert(make_pair(Person("Father", 76), 2000));
    //This record won't be inserted since Person with name Father is already there operator < will reject adding this to the map.
    //But the value only get updated.
    //if you want Father Person to be added consdier change the age and change the operator < overloading method with age comparision .

    records.insert(make_pair(Person("Father", 77), 3000));
    for (map<Person, int>::iterator it = records.begin(); it != records.end(); it++) {
        it->first.Print();
        cout << it->second;
    }

    return 0;
}

////////////////////////
// Assingment Operator
#include <iostream>
#include <string>
using namespace std;

class Person {
private:
    string name;
    int age;
public:
    Person() :name(""), age(0) {
        cout << "Paramterless Constructor is called" << endl;
    }

    Person(string name, int age) :name(name), age(age) {
        cout << "Parameter Constructor is called" <<endl;
    }

    Person(const Person& other) {
        age = other.age;
        name = other.name;
        cout << "Copy Constructor is called" << endl;
    }

   const Person &operator= (const Person &other){
       cout << "Assingment is called" << endl;
       age = other.age;
       name = other.name;
       return *this;
    }

    // always first argument to any member method is the [this] operator.
    void Print() const{
        cout << "name :" << name << "age:" << age << endl;
    }
};

using namespace std;
int main() {
    Person person1,person2("Surya",40),person3("Apan" ,35);
    person1.Print();
    //person1 = person2;
    // the default operator call on the class person.Shallow copy.
    //person1.operator= (person2);
    //person2 = person3;
    //person2.Print();
    // Operator= won't be called , but copy constructor will get called.
    // Copy Intialization.
    Person person4 = person3;
    person4.Print();
	return 0;
}
//////////////////
// Left shit  Operator
#include <iostream>
#include <string>
using namespace std;

class Person {
private:
    string name;
    int age;
public:
    Person() :name(""), age(0) {
        cout << "Paramterless Constructor is called" << endl;
    }

    Person(string name, int age) :name(name), age(age) {
        cout << "Parameter Constructor is called" <<endl;
    }


   const Person &operator= (const Person &other){
       cout << "Assingment is called" << endl;
       age = other.age;
       name = other.name;
       return *this;
    }

    // always first argument to any member method is the [this] operator.
    void Print() const{
        cout << "name :" << name << "age:" << age << endl;
    }
    // since we need to access the private member we are using friend . else we could use the getter method.
   friend ostream &operator<<(ostream &out, const Person &other) {
       out << other.name << other.age; 
       return out;
    }
};
// + is having right associative int x = 1 + 2+ 3 , first 2+ 3 will add then it adds 1.
// left shift having left to right associative.

using namespace std;
int main() {
    Person person1,person2("Surya",40),person3("Apan" ,35);
    //person1.Print();
    Person person4 = person3;
    //person4.Print();
    // instead of having print in the class how about overloading the left shift operator.
    cout << person4 << endl;
    // left to right associative. 
    cout << person4 <<  person2 << endl;
    // for the above statement to work we have to overload the operator <<
	return 0;
}

//////////////////
// Complex Number in C++
#include <iostream>
#include <string>
using namespace std;

class Complex {
private:
    double real;
    double imaginary;
public:
    Complex() : real(0), imaginary(0) {
        cout << "Paramterless Constructor is called" << endl;
    }

    Complex(double real,double imaginary) : real(real),imaginary(imaginary)
    {
        cout << "Paramter Constructor is called" << endl;
    }

    Complex(const Complex &other) {
        real = other.real;
        imaginary = other.imaginary;
        cout << "Copy" << endl;
    }

    const Complex& operator= (const Complex &other){
        real = other.real;
        imaginary = other.imaginary;
        return *this; 
    }
    double getReal() const{
        return real;
    }
    double getImaginary() const {
        return imaginary;
    }
 
};

ostream& operator<< (ostream& out, const Complex& other) {
    out << other.getReal() << ":" << other.getImaginary();
    return out;
}


// + is having right associative int x = 1 + 2+ 3 , first 2+ 3 will add then it adds 1.
// left shift having left to right associative.

using namespace std;
int main() {
    Complex c1(10,20);
    Complex c2(12,2);
    Complex c3 = c2;
    cout << c3 << c1;
	return 0;
}
////////////////////
// Complex Number in C++ continued 2
#include <iostream>
#include <string>
using namespace std;

class Complex {
private:
    double real;
    double imaginary;
public:
    Complex() : real(0), imaginary(0) {
        cout << "Paramterless Constructor is called" << endl;
    }

    Complex(double real,double imaginary) : real(real),imaginary(imaginary)
    {
        cout << "Paramter Constructor is called" << endl;
    }

    Complex(const Complex &other) {
        real = other.real;
        imaginary = other.imaginary;
        cout << "Copy" << endl;
    }

    const Complex& operator= (const Complex &other){
        real = other.real;
        imaginary = other.imaginary;
        return *this; 
    }
    double getReal() const{
        return real;
    }
    double getImaginary() const {
        return imaginary;
    }
 
};

ostream& operator<< (ostream& out, const Complex& other) {
    out << other.getReal() << ":" << other.getImaginary();
    return out;
}

Complex operator+(const Complex &c1,const Complex &c2) {
    return Complex(c1.getReal() + c2.getReal() ,c1.getImaginary() + c2.getImaginary());
}


// + is having right associative int x = 1 + 2+ 3 , first 2+ 3 will add then it adds 1.
// left shift having left to right associative.

using namespace std;
int main() {
    Complex c1(10,20);
    Complex c2(12,72);
    Complex c3 = c2;
    //cout << c3 << c1;
    cout << c3 + c1 + c2;
	return 0;
}

//////
// Complex Number in C++ continue 3
#include <iostream>
#include <string>
using namespace std;

class Complex {
private:
    double real;
    double imaginary;
public:2
    Complex() : real(0), imaginary(0) {
        cout << "Paramterless Constructor is called" << endl;
    }

    Complex(double real,double imaginary) : real(real),imaginary(imaginary)
    {
        cout << "Paramter Constructor is called" << endl;
    }

    Complex(const Complex &other) {
        real = other.real;
        imaginary = other.imaginary;
        cout << "Copy" << endl;
    }

    const Complex& operator= (const Complex &other){
        real = other.real;
        imaginary = other.imaginary;
        return *this; 
    }
	
    double getReal() const{
        return real;
    }
	
    double getImaginary() const {
        return imaginary;
    }
 
};

ostream& operator<< (ostream& out, const Complex& other) {
    out << other.getReal() << ":" << other.getImaginary();
    return out;
}

Complex operator+(const Complex &c1,const Complex &c2) {
    return Complex(c1.getReal() + c2.getReal() ,c1.getImaginary() + c2.getImaginary());
}

Complex operator+(const Complex& c1, double r) {
    return Complex(c1.getReal() + r, c1.getImaginary() );
}

// + is having right associative int x = 1 + 2+ 3 , first 2+ 3 will add then it adds 1.
// left shift having left to right associative.

using namespace std;
int main() {
    Complex c1(10,20);
    Complex c2(12,72);
    Complex c3 = c2 + 100;
    // this statement wont work since the + operator , first arg is double and second is complex 
    // but in our operator overloading we have complex as first arg complex and double as the second arg.
    //Complex c3 =  100 + c2;
    //cout << c3 << c1;
    cout << c3;
	return 0;
}

//////////////////////////
// Function Pointer
#include <iostream>
#include <string>
using namespace std;

bool Test(string name , bool flag) {
    cout << name <<"\t awsome programmer : " << flag << endl;
    return flag;
}

using namespace std;
int main() {
    //void (*funcPointer)() = Test;
    bool(*funcPointerString)(string,bool) = Test;
       bool temp = funcPointerString("Surya",true);
       cout << temp;
	return 0;
}
///////////////
Copy Construtor and order of the construtor called, Object slicing.
// to avoid object being sliced , use pass by reference or by pointer.
#include <iostream>
#include <string>
using namespace std;

class Parent {
private: 
    int one;
public:
    Parent():one(0) {
        cout << "Parent Constructor\n";
    }

    virtual void Print() {
        cout << "Parent Print\n" << endl;
    }

    Parent(const Parent &other) {
        cout << "Parent Copy Constructor\n" << endl;
        one = other.one;
    }

    virtual ~Parent() {
        cout << "Parent Destructor\n";
    }
};

class Child : public Parent {
private : 
    int two;
public :
    Child():two(0) {
        cout << "Child Constructor\n";
    }
    void Print() {
        cout << "Child Print\n" << endl;
    }
    ~Child() {
        cout << "Child Destructor\n";
    }
    
};

int main() {
    Child c1;
    Parent &p1 = c1;
    // try removing the virtual key word in the parent.
    p1.Print();
    // Parent Copy Constructor is get called. Copy Initialization.
    Parent p2 = Child(); //Object Slicing.
    p2.Print();
	return 0;
}
///////////////////////
Pure Virtual Methods , Abstract class.
#include <iostream>
#include <string>
using namespace std;

class Parent {
private: 
    int one;
public:
    Parent():one(0) {
        cout << "Parent Constructor\n";
    }
    virtual void Print() = 0;
    virtual void Display() = 0;
};

class Child : public Parent {
private : 
    int two;
public :
    Child() {
        cout << "Child Constructor\n";
    }

    virtual void Print() {
        cout << "Hello";
    }
};

int main() {
    Child c;
    c.Print();
	return 0;
}

/////////////
Abstract Class and Run time polymorphism. With Deep Hierachy.
#include <iostream>
#include <string>
using namespace std;

class Parent {
private: 
    int one;
public:
    Parent():one(0) {
        cout << "Parent Constructor\n";
    }
    virtual void Print() = 0;
    virtual void Display() = 0;
};

class FirstChild : public Parent {
    private: 
    int two;
public :
    FirstChild() {
        cout << "FirstChild Constructor\n";
    }

    virtual void Print() {
        cout << "Hello FirstChild";
    }
};

class SecondChild : public FirstChild {
private:
    int three;
public:
    SecondChild() {
        cout << "SecondChild Constructor\n";
    }

    virtual void Display() {
        cout << "Display in the Second child";
    }
};

int main() {
    // Compile time error since pure virtual function. Display not imPlemented.
    // Only second child is allowed to instantiate.
    // FirstChild f;
    // Array of second child invoke constructor of the class.
    // Infact array of any class will invoke its own class constructor.
    SecondChild s[5];
    s[0].Print();

    Parent* ParentPointer[5];
    ParentPointer[0] = &s[0];
    ParentPointer[0]->Display();
	return 0;
}

////////////////////////
Moden C++ Auto,dectype
#include <iostream>
#include <string>
#include<typeinfo>

using namespace std;
class Parent {
private:
    int one;
public:
    Parent() :one(0) {
        cout << "Parent Constructor\n";
    }
};

template<typename T, typename U>
auto Sum(T t,U u) -> decltype(u){
    return t + u;
}

int main() {
    Parent p;
    string val;
    auto v = "sfsfd";
    cout << typeid(v).name();
    //string name = "Surya";
    decltype(val) name = "Surya";
    //cout << name;
    cout << Sum(10,"Narayanan");
    //cout << MyMethod();
	return 0;
}

////////////////////
Auto and nested class. Bad way of doing the nested class.
#include <iostream>
#include<typeinfo>

using namespace std;

class Ring {
public:
    Ring() {
    }
    virtual ~Ring() {
    }
    class Iterator {
    public:
        Iterator() {
        }
        void Print() {
            cout << "Iterator";
        }
    };
};
int main() {
    const char* names[] = { "one","two","three" };
    auto names2 = {"one","two","three"};
    for (auto text: names2) {
        cout << text;
    }

    Ring::Iterator it;
    it.Print();
	return 0;
}

///////////////////
Auto and nested class. Better way of doing the nested class.
#include <iostream>
#include<typeinfo>

using namespace std;

class Ring {
public:
    Ring() {
    }
    virtual ~Ring() {
    }
    class Iterator;
};

class Ring::Iterator {
public:
    Iterator() {
    }
    void Print() {
        cout << "Iterator";
    }
};
int main() {
    const char* names[] = { "one","two","three" };
    auto names2 = {"one","two","three"};
    for (auto text: names2) {
        cout << text;
    }

    Ring::Iterator it;
    it.Print();
	return 0;
}
///////////
#include <iostream>
#include<typeinfo>

using namespace std;
template<typename T>
class Ring {
public:
    Ring() {
    }
    virtual ~Ring() {
    }
    class Iterator;
};

template<typename T>
class Ring<T>::Iterator {
public:
    Iterator() {
    }
    void Print() {
        cout << "Iterator" << T();
    }
};
int main() {
    const char* names[] = { "one","two","three" };
    auto names2 = {"one","two","three"};
    for (auto text: names2) {
        cout << text;
    }

    Ring<int>::Iterator it;
    //Default intializing of int is 0.
    it.Print();
	return 0;
}
////
Intialization in c++ 98
#include <iostream>
#include<typeinfo>

using namespace std;
struct employee {
    string name;
    int t;

}e1 = { "asdfsdf", 90 }, e2 = {"sdfsdf", 90};

int main() {
    employee e = { "Surya" , 10 };
    cout << e1.name;
	return 0;
}
//////////
#include <iostream>
#include<typeinfo>
#include <initializer_list>
using namespace std;
class Employee {
public:
    Employee(initializer_list<string> names) {
        for (auto s : names) {
            cout << s << "\t";
        }
    }

    void Print(initializer_list<string> l) {
        for (auto k : l) {
            cout << k << "\t";
        }
    }
};



int main() {
    Employee e{ "one","two","three","four" };
    e.Print({"five","six","seven"});
	return 0;
}
///////////////////
Default Initalizing Objects.
#include <iostream>
#include<typeinfo>
#include <initializer_list>
using namespace std;

class Employee {
    int age{ 10 };
    int salary = 1000;
    string typeOfEmployment{ "direct" };
public:
    Employee() = default;
    Employee(const Employee &other) = default;
   Employee &operator=(const Employee &other) = delete;

    Employee(int age):age(age) {
    }

    void Print() {
        cout << typeOfEmployment << age << "\t" << salary << endl;
 }
};

int main() {
    Employee e;
    e.Print();
    cout << endl;
    // this over rides the default value. of the age member.
    Employee e2(40);
    Employee e3 = e2;
    e3.Print();
	return 0;
}			
///////////
Lambda Expression Part1
#include <iostream>
using namespace std;
void FunctionPointerUsingLambda(void (*PointerToFunc)()) {
    PointerToFunc();
}
int main() {
    auto LambdaExpression = []() {cout << "Lambda Expression" << endl; };
    //func();
     //[]() {cout << "Lambda Expression" << endl; }();
     //FunctionPointerUsingLambda(LambdaExpression);
     FunctionPointerUsingLambda([]() {cout << "Lambda Expression" << endl; });

	return 0;
}
//////////////
#include <iostream>
using namespace std;
void FunctionPointerUsingLambda(void (*PointerToFunc)()) {
    PointerToFunc();
}

void LambdaWithArguments(void(*pointerFunc)(string)) {
    pointerFunc("Mother");
}

void LambdaWithArugAndReturnType(double (*pointFunc)(double a, double b)) {
    auto rval =  pointFunc(100.2,34);
    cout << rval;
}

int main() {
    auto LambdaExpression = []() {cout << "Lambda Expression" << endl; };
    //func();
     //[]() {cout << "Lambda Expression" << endl; }();
     //FunctionPointerUsingLambda(LambdaExpression);
     FunctionPointerUsingLambda([]() {cout << "Lambda Expression" << endl; });

     auto Lambda2 = [](string name) {cout << "Hello" << name; };
     Lambda2("Surya");
     LambdaWithArguments(Lambda2);
     auto Lambda3 = [](double a, double b) -> double {
         if (b == 0) {
             return 0;
         }
         else
         {
             return  a / b;
         }
         };
     cout << endl;
     cout << Lambda3(12.0, 0);
     cout << endl;
     LambdaWithArugAndReturnType(Lambda3);
	return 0;
}
////////////////////
Capture Local Variables in Lambda expressions
#include <iostream>
using namespace std;
void FunctionPointerUsingLambda(void (*PointerToFunc)()) {
    PointerToFunc();
}

void LambdaWithArguments(void(*pointerFunc)(string)) {
    pointerFunc("Mother");
}

void LambdaWithArugAndReturnType(double (*pointFunc)(double a, double b)) {
    auto rval =  pointFunc(100.2,34);
    cout << rval;
}

int main() {
    int age{40};
    string name{"Suryanarayanan"};
    float salary{ 100000.0 };
    auto LambdaExpression = []() {cout << "Lambda Expression" << endl; };
    //func();
     //[]() {cout << "Lambda Expression" << endl; }();
     //FunctionPointerUsingLambda(LambdaExpression);
     FunctionPointerUsingLambda([]() {cout << "Lambda Expression" << endl; });

     auto Lambda2 = [](string name) {cout << "Hello" << name; };
     Lambda2("Surya");
     LambdaWithArguments(Lambda2);
     auto Lambda3 = [](double a, double b) -> double {
         if (b == 0) {
             return 0;
         }
         else
         {
             return  a / b;
         }
         };
     cout << endl;
     cout << Lambda3(12.0, 0);
     cout << endl;
     LambdaWithArugAndReturnType(Lambda3);
     cout << "@@@@@@@@@@@" << endl;
     //Acpturing the local varliables in lambda expressions
     [age, name]() { cout << "Name:" << name << "Age:" << age << endl; }();
     cout << "@@@@@@@@@@@" << endl;
     // Capture all the variables as value.
     [=]() {cout << "Name:" << name << "Age:" << age << endl; }();
     cout << "@@@@@@@@@@@" << endl;
     //Capture all the local variables as reference.
     [&]     ()     {
         name = "Mother";
         cout << "Name:" << name << "Age:" << age << endl; 
     }  ();
     [=,&salary]() {         salary = 1500000;
     cout << "Name:" << name << "Age:" << age <<"\tSalary:\t" << salary << endl; }();
	 //use this operator to capture the member variable in class. all the member variable will be reference type only.
	      [this]() {         salary = 1500000;
     cout << "Name:" << name << "Age:" << age <<"\tSalary:\t" << salary << endl; }();
	return 0;
}

// Constructor Intialization list is better than , having the intialization in the body. since the later one is //like assingment , for complex class[composite class or class with a class] assingment is a memory over head.
// debug the code and examine the this pointer. then you will understand the above fact.
#include<iostream>
#include<string>
#include<typeinfo>
using namespace std;

class Parent {
private:
    int zero;
public:
    Parent() :zero{0} {
        cout << "Parent Constructor\n";
    }
    virtual void Print() {
        cout << zero << "Zero\n";
    }   
};

class FirstChild : public Parent {
private:
    int one;
public:
    FirstChild() :one{1} {
        cout << "FirstChild Constructor\n";
    }

     void Print() {
        cout << "Hello FirstChild" << one;
    }
};

class SecondChild : public FirstChild {
private:
    int second;
    string name;
public:
    SecondChild() :second{ 2 } {
        cout << "SecondChild Constructor\n";
    }

    SecondChild(int x, string n) :second{ x }, name{ n }{

    }

    void Print() {
        cout << "Second Child" << second << name ;
    }

    void Increment() {
        second++;
    }
    
};

int main() {
 
    Parent* parentBaseClass = new SecondChild(22,"asdfasdf");
    parentBaseClass->Print();
    //Parent* ParentPointer[5];
    //ParentPointer[0] = &s[0];
    //const std::type_info &ti = typeid(ParentPointer[0]);
    //if (ti == typeid(SecondChild)) {
    //    cout << "\n" << ti.name();
    //}
    // RTTI is useful while down casting. 
    
    return 0;
}
//dynamic_cast
#include <iostream>
#include <string>
using namespace std;
// The parent class
class Shape {
    string s_name;
public:
    Shape(string name) : s_name(name) {}
    virtual void get_info() {
        cout << s_name << endl;
    }
};
// The child class
class Square : public Shape {
    int side;
public:
    Square(string S_name, int value)
        : Shape(S_name), side(value) {}
    void get_info() {
        cout << "Area of the square is: " << side * side << endl;
    }
};
// The child class
class Rectangle : public Shape {
    int length;
    int width;
public:
    Rectangle(string S_name, int len, int wid)
        : Shape(S_name), length(len), width(wid) {}
    void get_info() {
        cout << "Area of the rectangle is: " << length * width << endl;

    }
};
Shape* create_square(string S_name, int value) {
    return new Square(S_name, value);
}
Rectangle* create_rectangle(string S_name, int len, int wid) {
    return new Rectangle(S_name, len, wid);
}
int main() {
    // quad is the pointer to the parent
    // class, it needs to be casted to be used to
    // access the method of the child class.
    Shape* quad = create_square("Quadliteral", 4);
    // Trying to downcast the parent class pointer to
    // the child class pointer.
    Square* sq = dynamic_cast<Square*>(quad);
    // dynamic_cast returns returns null if the type
    // to be casted into is a pointer and the cast
    // is unsuccessful.
    if (sq) {
        sq->get_info();
    }
    Rectangle* rect = create_rectangle("Quadliteral", 4, 5);
    // An example of a valid upcasting
    Shape* quad1 = dynamic_cast<Shape*>(rect);
    // An example of invalid downcasting
    Square* sq1 = dynamic_cast<Square*>(quad1);
    if (sq1 == NULL) {
        cout << "Invalid casting." << endl;
    }
}

#include <iostream>
//Old Code
//int Max(int x, int y) {
//	return x > y ? x : y;
//}
//float Max(float x, float y) {
//	return x > y ? x : y;
//}

//Primary Template
template<typename T>
T Max(T x, T y) {
	std::cout << typeid(T).name() << std::endl;
	return x > y ? x : y;
}
//Explicit Instantiation
template char Max(char x, char y);

//Explicit Specialization
template<> const char * Max<const char*>(const char *x, const char *y) {
	std::cout << "Max<const char*>()" << std::endl;
	return strcmp(x, y) > 0 ? x : y;
}

void Examples() {
#pragma region Instantiation Examples
	Max(static_cast<float>(3), 5.5f);

	//Override compiler's deduction process
	Max<double>(3, 6.2);

	//Causes implicit instantiation of Max<int>
	int(*pfn)(int, int) = Max;

#pragma endregion
#pragma region Explicit Instantiation
	const char *b{ "B" };
	const char *a{ "A" };
	auto s = Max(a, b);
	std::cout << s << std::endl;
#pragma endregion
}

//Non-type template parameter
template<int size>
void Print() {
	char buffer[size];
	std::cout << size << std::endl;
}
//Requires size as explicit argument
template<typename T>
T Sum(T*parr, int size){
	T sum{};
	for (int i = 0; i < size; ++i) {
		sum += arr[i];
	}
	return sum;
}
//Size is implicitly calculated in non-type template argument
template<typename T,int size>
T Sum(T (&arr)[size]) {
	T sum{};
	for (int i = 0; i < size; ++i) {
		sum += arr[i];
	}
	return sum;
}
int main() {
	Print<3>();
	int arr[]{ 3,1,9,7 };
	//int (&ref)[5] = arr ;
	int sum = Sum(arr);
	std::cout << sum << std::endl; 
	return 0;
}
////Templates Code Sample
#include <iostream>
using namespace std;

template<typename T>T Add(T x, T y) {
    return x + y;
}

//int ArraySum(int* pArr, int arrSize); //Returns the sum of array elements
template<typename T>T ArraySum(T* pArr,T arrSize) {
    T sum{ 0 };
    for (int i = 0; i < arrSize; i++) {
        sum += pArr[i];
    }
    return sum;
}

//int Max(int* pArr, int arrSize); //Return the largest element in the array
template<typename T>
T Max(T* ptr,T noOfElements) {
    // Formula to find the total elements 
    //constexpr std::size_t totalElement = sizeof(ptr) / sizeof(*ptr);
    std::qsort(ptr, noOfElements,sizeof(*ptr), [](const void* a, const void* b)
    {
        T arg1 = *static_cast<const T*>(a);
        T arg2 = *static_cast<const T*>(b);

        if (arg1 > arg2) return -1;
        if (arg1 < arg2) return 1;
        return 0;

        //  return (arg1 > arg2) - (arg1 < arg2); // possible shortcut
        //  return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)
    });
    //for (int ai : ptr)
    //    std::cout << ai << ' ';
    return *ptr;
}

int main() {
    int data[]{ 10,20,30 };
    float scores[]{ 12.74f,6.6f,4.6f,12.2f };
    //pointer pointing to the array of 3 ints.
    //int(*ptr)[3] = &data;
    cout << "ArraySum" << ArraySum(scores, static_cast<float>(4)) << endl;
    // how to type convert the float array as int array. in the above case of scores. challenge.
    cout << Add(scores[0],scores[1]);
    cout << "Max is" << Max(scores,static_cast<float>(4));
	    // example for template address , for template instantiation.Max is not called, this will generate the template code for Max deduce int for typename.
    int (*ptrMax)(int*, int) = Max;
	return 0;
}
/////Dynamic Cast/////
// For correcting the downcast.since quad can not access the member of the square class . dynamic_cast is //required to properly do the down cast.
//dynamic_cast
#include <iostream>
#include <string>
using namespace std;
// The parent class
class Shape {
    string s_name;
public:
    Shape(string name) : s_name(name) {}
    virtual void get_info() {
        cout << s_name << endl;
    }
};
// The child class
class Square : public Shape {
    int side;
public:
    Square(string S_name, int value)
        : Shape(S_name), side(value) {}
    void get_info() {
        cout << "Area of the square is: " << side * side << endl;
    }

    int getValue() {
        return side;
    }
};
// The child class
class Rectangle : public Shape {
    int length;
    int width;
public:
    Rectangle(string S_name, int len, int wid)
        : Shape(S_name), length(len), width(wid) {}
    void get_info() {
        cout << "Area of the rectangle is: " << length * width << endl;
    }
};
Shape* create_square(string S_name, int value) {
    return new Square(S_name, value);
}
Rectangle* create_rectangle(string S_name, int len, int wid) {
    return new Rectangle(S_name, len, wid);
}
int main() {
    // quad is the pointer to the parent
    // class, it needs to be casted to be used to
    // access the method of the child class.
    Shape* quad = create_square("Quadliteral", 4);
    // Trying to downcast the parent class pointer to
    // the child class pointer.
    Square* sq = dynamic_cast<Square*>(quad);
    // dynamic_cast returns returns null if the type
    // to be casted into is a pointer and the cast
    // is unsuccessful.
    if (quad) {
        quad->get_info();
    }
    Shape* rect = create_rectangle("Quadliteral", 4, 5);
    //rect->get_info();

    //// An example of a valid upcasting
    //Shape* quad1 = dynamic_cast<Shape*>(rect);
    //// An example of invalid downcasting
    Square* sq1 = dynamic_cast<Square*>(rect);
    if (sq1 == NULL) {
        cout << "Invalid casting." << endl;
    }

}
/////////////////Stack using array in template. form
#include <iostream>
template<typename T,int size>
class Stack {
	T m_Buffer[size];
	int m_Top{ -1 };
public:
	Stack() = default;
	Stack(const Stack<T, size> &obj) {
		m_Top = obj.m_Top;
		for (int i = 0; i <= m_Top; ++i) {
			m_Buffer[i] = obj.m_Buffer[i];
		}
	}
	void Push(const T &elem) {
		m_Buffer[++m_Top] = elem;
	}
	void Pop();
	const T& Top()const {
		return m_Buffer[m_Top];
	}
	bool IsEmpty() {
		return m_Top == -1; 
	}
	/*
	Shorthand notation for class name as return type,
	because it appears inside the class
	*/
	static Stack Create();
};

template<typename T, int size>
void Stack<T, size>::Pop() {
	--m_Top;
}

template<typename T, int size>
/*
Longhand notation for class name as return type,
because it appears outside the class
*/
Stack<T, size> Stack<T, size>::Create() {
	return Stack<T, size>();
}
int main() {
	/*
	The template parameter list is part of the type of class.
	The following code will not work.

	Stack<float, 9> s = Stack<float, 10>::Create();
				 ^
	*/
	Stack<float, 10> s = Stack<float, 10>::Create();
	s.Push(3);
	s.Push(1);
	s.Push(6);
	s.Push(9);
	auto s2(s);
	while (!s2.IsEmpty()) {
		std::cout << s2.Top() << " ";
		s2.Pop();
	}
	Stack<char *, 5> ss;
	ss.Push("Hello");
	auto ss2(ss);
	return 0;
}
#include<iostream>
using namespace std;

template<typename T>
class LinkedList {
    struct Node {
        T val;
        Node* next;
        Node(T arg) :val{ arg }, next{ nullptr }{
            cout << "Node Ctor" << endl;
        };
        ~Node() {
            cout << "Node Dtor" << endl;
        }
    };
    Node* head;
    int count;
public:

    LinkedList() :head{ nullptr }, count{ 0 }{
        cout << "Linked List Ctor called" << endl;
    };
    ~LinkedList() {
        // delete all the nodes.
        cout << "LinkedList Dtor called" << endl;
        if (head != nullptr) {
            while (head != nullptr) {
                head = head->next;
                delete head;
            }
        }
    }
    template<typename T>
    void AddNodeAtHead(const T& val) {
        if (head == nullptr) {
            head = new Node{val};
            head->next = nullptr;
        }
        else {
            Node* temp = new Node{val};
            temp->next = head;
            head = temp;
        }
        count++;
    }


    void displayList() {
        if (head != nullptr) {
            Node* temp = head;
            while (temp != nullptr) {
                cout << temp->val << "\t";
                temp = temp->next;
            }
        }
    }
};

int main() {
    LinkedList<int> list;
    list.AddNodeAtHead(10);
    list.AddNodeAtHead(20);
    list.AddNodeAtHead(200);
    list.AddNodeAtHead(2200);
    list.displayList();
}
//////
#include <iostream>
#include<array>
using namespace std;

int main() {
	array<int, 5> myarray1{ 2,3,4,5,6 };
	array<int, 5> myarray2 = { 2,3,4,5,6 };
	array<int, 5> myarray3;
	myarray3 = { 2,3,4,5,6 };
	array<int, 5> myarray4;
	myarray4.fill(300);

	cout <<"Value at 5 " << myarray1.at(3);
	cout << "Value at index 2" << myarray1[2]<<endl;
	cout << "Value at index 0" << myarray1.front()<<endl;
	cout << "Value at index end" << myarray1.back()<<endl;
	cout << "All Value at " << myarray1.data();
	cout << "All Value at myarray" << myarray4.at(4);
	return 0;
}

///////////////////////////
#include <iostream>
#include<vector>
using namespace std;
//main draw back of using vector is ,dynamic size increase, while doing so it will allocate double the 
// size of the allocation and TODO learn internal working of the Vector in c++.
//vector.reserve(max size) ; will allocate the max capacity before hand so that dynamic capcity , copy wont affect the  performance.
int main() {
	vector<int> myvector1;
	vector<int> myvector3(5,20); //store for 5 elements with value 20 in each.
	vector<int> myvector2; // create empty vector.
	//cout << "value at 4 using at\t" << myvector1.at(4)<< endl; // this is exception safe.
	//cout << "value at 6 using []" << myvector1[6] << endl; // this not is exception safe.
	for (int i = 0; i < 32; i++) {
		myvector1.push_back(i);
		cout <<"Capacity\t" << myvector1.capacity() << "Size\t" << myvector1.size()<<endl;
	}
	return 0;
}
////////////////////////
TODO
what is the difference between the following set of codes.
#include <iostream>
#include<set>
using namespace std;
int main() {
	set<int> myset{ 1,4,2,7,4,6,9,2,4,5,1,0,3 };
	for (auto e : myset) {
		cout << e ;
	}
	cout << endl;
	for (const auto e : myset) {
		cout << e;
	}
	cout << endl;
	for (const auto &e : myset) {
		cout << e;
	}
	return 0;
}
/////////////////////////////
#include <iostream>
#include<set>
#include<functional>
using namespace std;
// set is a container with only unique SORTED elements.
// it is implemented using red black tree .
//we can pass the sorting order while constructing the set.
//set<int,greater>
//set<int,less>
// if we want to store user defined types , then we have to provide the comparision function so that set will sort the datas and store.
class Person {
public:
	string Name;
	int age;
	bool operator < (const Person& rhs) const { return age > rhs.age; }
	bool operator > (const Person& rhs) const { return age < rhs.age; }
};
int main() {
	set<Person,std::less<>> myset = { {"surya",40},{"shalika",9},{"aparna",35},{"prvarthika",5} };
	for (const auto &p: myset) {
		cout << p.Name << "\t";
	}

	return 0;
}
/////
TODO  pls refere cppnuts video on container inside a container.
construct a tree using vector inside a vector. coding pending.

#include <iostream>
#include<set>
#include<functional>
#include <vector>
#include<algorithm>
#include <string>
using namespace std;
// set is a container with only unique SORTED elements.
// it is implemented using red black tree .
//we can pass the sorting order while constructing the set.
//set<int,greater>
//set<int,less>
// if we want to store user defined types , then we have to provide the comparision function so that set will sort the datas and store.
class Person {
public:
	string Name;
	int age;
	bool operator < (const Person& rhs) const { return age > rhs.age; }
	bool operator > (const Person& rhs) const { return age < rhs.age; }

};
//[[deprecated]]
//int MyMethod() {
//	return 10;
//}
//variable templates.
int main() {
	vector<int> myVec{ 4,3,34,2,7,33,88,123 };
	vector<int> newVec;
	int sum = 0;
	sort(myVec.begin(), myVec.end(), [](int x, int y) {return x < y; }); // Example for lambda
	long decimalVal = 1'000'00; // new feature digit separator in c++ 14
	int b = 0b11111; // new feature binary literal
	copy_if(myVec.begin(), myVec.end(), back_inserter(newVec), [](int x) {return (x % 2) == 0;});
	for_each(myVec.begin(), myVec.end(), [&](int x) {sum += x; });
	set<Person,std::less<>> myset = { {"surya",40},{"shalika",9},{"aparna",35},{"prvarthika",5} };
	for (const auto &p: myset) {
		cout << p.Name << "\t";
	}
	//cout << MyMethod();
	//auto add = [](auto x, auto z){return x + z};
	//TODO decltype

	cout << "Generic lambda" << add(12 , 12);
	cout << "Generic lambda" << add("surya" , "gaming");
	cout << decimalVal << endl;
	cout << b << endl;
	for (const auto& v : myVec) {
		cout << v << "\t";
	}
	cout << endl << "\\\\\\\\\\\\\\\\\\\\\\" << endl;
	for (const auto& v : newVec) {
		cout << v << "\t";
	}
	cout << endl << "\\\\\\\\\\\\\\\\\\\\\\" << endl;
	cout << "Sum \t" << sum;
	return 0;
}

// set is a container with only unique SORTED elements.
// it is implemented using red black tree .
//we can pass the sorting order while constructing the set.
//set<int,greater>
//set<int,less>
// if we want to store user defined types , then we have to provide the comparision function so that set will sort the datas and store.

	// Creates a max heap 
	priority_queue <int> pq;
	int nums[]{ 2,33,5,66,7,22,1,66,234,7,4 };
	for (int n : nums) {
		pq.push(n);
	}

	// One by one extract items from max heap 
	while (pq.empty() == false)
	{
		cout << pq.top() << " ";
		pq.pop();
	}
	
	////////////////// 
	How this code Behave.
vector fill(istream& is)
{
vector res;
for (double x; is>>x; ) res.push_back(x);
return res;
}

////////////////
// string::crbegin/crend
#include <iostream>
#include <string>

int main ()
{
  std::string str ("lorem ipsum");
  for (auto rit=str.crbegin(); rit!=str.crend(); ++rit)
    std::cout << *rit;
  std::cout << '\n';

  return 0;
}
//Return const_reverse_iterator to reverse beginning
//Returns a const_reverse_iterator pointing to the last character of the string (i.e., its reverse beginning).
///

int main() {

	int scores[]{ 100, 95, 89 };

	cout << "Value of scores: " << scores << endl;

	int* score_ptr{ scores };
	cout << "Value of score_ptr: " << score_ptr << endl;

	cout << "\nArray offset notation-------------------------" << endl;
	cout << *scores << endl;
	cout << *(scores + 1) << endl;
	cout << *(scores + 2) << endl;

	cout << endl;
	return 0;
}
////
void display(int* array, int sentinel) {
	while (*array != sentinel)
		cout << *array++ << " ";// *(array + 1)
	cout << endl;
}

/////////////

Moden C++ Auto,dectype
#include <iostream>
#include <string>
#include<typeinfo>

using namespace std;
class Parent {
private:
    int one;
public:
    Parent() :one(0) {
        cout << "Parent Constructor\n";
    }
};

template<typename T, typename U>
auto Sum(T t,U u) -> decltype(u){
    return t + u;
}

int main() {
    Parent p;
    string val;
    auto v = "sfsfd";
    cout << typeid(v).name();
    //string name = "Surya";
    decltype(val) name = "Surya";
    //cout << name;
    cout << Sum(10,"Narayanan");
    //cout << MyMethod();
	return 0;
}
////////////////